{"version":3,"file":"stream.min.js","sources":["../src/stream.js"],"names":["window","VERSION","Pipeline","collection","pipeline","this","lastOp","StatelessOp","arg","add","op","prev","next","advance","filter","predicate","assertFn","filtered","call","ctx","map","mapper","flatMap","sorted","comparator","StatefulOp","finisher","array","sort","skip","num","obj","i","limit","voter","peek","consumer","distinct","indexOf","terminal","toArray","current","result","eop","push","findFirst","Optional","empty","ofNullable","findLast","last","forEach","fn","min","defaultComparator","max","sum","average","count","allMatch","match","anyMatch","noneMatch","collect","collector","identity","supplier","first","accumulator","reduce","arg0","arguments","arg1","reduceFirst","groupBy","keyMapper","key","hasOwnProperty","undefined","indexBy","mergeFunction","partitionBy","isFunction","partitionByPredicate","isNumber","partitionByNumber","length","partition","joining","options","prefix","suffix","delimiter","str","delim","String","consumed","assertNotConsumed","terminalProxy","terminalFn","apply","name","flat","data","isStashed","unstash","pipe","val","stash","buffer","flatten","keys","origin","fence","bufferedVal","nextBufferedVal","isArray","isObject","Object","voted","shift","isPresent","get","ifPresent","orElse","otherVal","orElseGet","orElseThrow","errorMsg","mappedVal","flatMapper","of","a","b","prototype","toString","Array","Stream","range","startInclusive","endExclusive","rangeClosed","endInclusive","previousStream","noConflict"],"mappings":"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","sourcesContent":["/**\n * Stream.js 0.2.0\n * https://github.com/winterbe/streamjs\n * Copyright (c) 2014-2015 Benjamin Winterberg\n * Stream.js may be freely distributed under the MIT license.\n */\n(function (window) {\n    \"use strict\";\n\n\n    var VERSION = \"0.2.0\";\n\n\n    //\n    // Internal Pipeline (doing all the work)\n    //\n\n    var Pipeline = function (collection) {\n        var pipeline = this;\n\n        // default op iterates over input array\n        var lastOp = new StatelessOp(function (arg) {\n            return arg;\n        }, true, collection);\n\n        this.add = function (op) {\n            if (lastOp !== null) {\n                var prev = lastOp;\n                op.prev = prev;\n                prev.next = op;\n            }\n\n            lastOp = op;\n        };\n\n        this.next = function () {\n            return lastOp.advance();\n        };\n\n\n        //\n        // intermediate operations (stateless)\n        //\n\n        this.filter = function (predicate) {\n            assertFn(predicate, \"predicate function argument required for filter\");\n            this.add(new StatelessOp(function (arg) {\n                var filtered = predicate.call(ctx, arg);\n                if (filtered) {\n                    return arg;\n                } else {\n                    return null;\n                }\n            }));\n            return this;\n        };\n\n        this.map = function (mapper) {\n            assertFn(mapper, \"mapper function argument required for map\");\n            this.add(new StatelessOp(function (arg) {\n                return mapper.call(ctx, arg);\n            }));\n            return this;\n        };\n\n        this.flatMap = function (mapper) {\n            assertFn(mapper, \"mapper function argument required for flatMap\");\n            this.add(new StatelessOp(function (arg) {\n                return mapper.call(ctx, arg);\n            }, true));\n            return this;\n        };\n\n\n        //\n        // intermediate operations (stateful)\n        //\n\n        this.sorted = function (comparator) {\n            this.add(new StatefulOp({\n                finisher: function (array) {\n                    array.sort(comparator);\n                }\n            }));\n            return this;\n        };\n\n        this.skip = function (num) {\n            this.add(new StatefulOp({\n                filter: function (obj, i) {\n                    return i >= num;\n                }\n            }));\n            return this;\n        };\n\n        this.limit = function (num) {\n            this.add(new StatefulOp({\n                voter: function (obj, i) {\n                    return i < num;\n                }\n            }));\n            return this;\n        };\n\n        this.peek = function (consumer) {\n            this.add(new StatefulOp({\n                consumer: consumer\n            }));\n            return this;\n        };\n\n        this.distinct = function () {\n            this.add(new StatefulOp({\n                filter: function (obj, i, array) {\n                    return array.indexOf(obj) < 0;\n                }\n            }));\n            return this;\n        };\n\n\n        //\n        // terminal operations\n        //\n\n        var terminal = {};\n\n        terminal.toArray = function () {\n            var current;\n            var result = [];\n            while ((current = pipeline.next()) !== eop) {\n                result.push(current);\n            }\n            return result;\n        };\n\n        terminal.findFirst = function () {\n            var obj = pipeline.next();\n            if (obj === eop) {\n                return Optional.empty();\n            }\n            return Optional.ofNullable(obj);\n        };\n\n        terminal.findLast = function () {\n            var current, last;\n            while ((current = pipeline.next()) !== eop) {\n                last = current;\n            }\n            if (last === eop) {\n                return Optional.empty();\n            }\n            return Optional.ofNullable(last);\n        };\n\n        terminal.forEach = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                fn.call(ctx, current);\n            }\n        };\n\n        terminal.min = function (comparator) {\n            comparator = comparator || defaultComparator;\n\n            var current, result = null;\n            while ((current = pipeline.next()) !== eop) {\n                if (result === null || comparator.call(ctx, current, result) < 0) {\n                    result = current;\n                }\n            }\n            return Optional.ofNullable(result);\n        };\n\n        terminal.max = function (comparator) {\n            comparator = comparator || defaultComparator;\n\n            var current, result = null;\n            while ((current = pipeline.next()) !== eop) {\n                if (result === null || comparator.call(ctx, current, result) > 0) {\n                    result = current;\n                }\n            }\n            return Optional.ofNullable(result);\n        };\n\n        terminal.sum = function () {\n            var current, result = 0;\n            while ((current = pipeline.next()) !== eop) {\n                result += current;\n            }\n            return result;\n        };\n\n        terminal.average = function () {\n            var current, count = 0, sum = 0;\n            while ((current = pipeline.next()) !== eop) {\n                sum += current;\n                count++;\n            }\n            return sum / count;\n        };\n\n        terminal.count = function () {\n            var current, result = 0;\n            while ((current = pipeline.next()) !== eop) {\n                result++;\n            }\n            return result;\n        };\n\n        terminal.allMatch = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                var match = fn.call(ctx, current);\n                if (!match) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        terminal.anyMatch = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                var match = fn.call(ctx, current);\n                if (match) {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        terminal.noneMatch = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                var match = fn.call(ctx, current);\n                if (match) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        terminal.collect = function (collector) {\n            var identity = collector.supplier.call(ctx);\n            var current, first = true;\n            while ((current = pipeline.next()) !== eop) {\n                identity = collector.accumulator.call(ctx, identity, current, first);\n                first = false;\n            }\n            if (collector.finisher) {\n                identity = collector.finisher.call(ctx, identity);\n            }\n            return identity;\n        };\n\n        terminal.reduce = function () {\n            var arg0 = arguments[0];\n            var arg1 = arguments[1];\n\n            if (arg1) {\n                return pipeline.collect({\n                    supplier: function () {\n                        return arg0;\n                    },\n                    accumulator: arg1\n                });\n            }\n\n            return reduceFirst(arg0);\n        };\n\n        var reduceFirst = function (accumulator) {\n            var current;\n\n            var identity = pipeline.next();\n            if (identity === eop) {\n                return Optional.empty();\n            }\n\n            while ((current = pipeline.next()) !== eop) {\n                identity = accumulator.call(ctx, identity, current);\n            }\n\n            return Optional.ofNullable(identity);\n        };\n\n        terminal.groupBy = function (keyMapper, map) {\n            return pipeline.collect({\n                supplier: function () {\n                    return map || {};\n                },\n                accumulator: function (map, obj) {\n                    var key = keyMapper.call(ctx, obj);\n                    if (!map.hasOwnProperty(key)) {\n                        map[key] = [];\n                    }\n\n                    if (map[key] === undefined) {\n                        map[key] = [];\n                    }\n\n                    map[key].push(obj);\n                    return map;\n                }\n            });\n        };\n\n        terminal.indexBy = function (keyMapper, mergeFunction, map) {\n            return pipeline.collect({\n                supplier: function () {\n                    return map || {};\n                },\n                accumulator: function (map, obj) {\n                    var key = keyMapper.call(ctx, obj);\n                    if (map.hasOwnProperty(key)) {\n                        if (!mergeFunction) {\n                            throw \"duplicate mapping found for key: \" + key;\n                        }\n                        map[key] = mergeFunction.call(ctx, map[key], obj);\n                        return map;\n                    }\n\n                    map[key] = obj;\n                    return map;\n                }\n            });\n        };\n\n        terminal.partitionBy = function () {\n            var arg0 = arguments[0];\n            if (isFunction(arg0)) {\n                return partitionByPredicate(arg0);\n            }\n            if (isNumber(arg0)) {\n                return partitionByNumber(arg0);\n            }\n            throw 'partitionBy requires argument of type function or number';\n        };\n\n        var partitionByPredicate = function (predicate) {\n            return pipeline.collect({\n                supplier: function () {\n                    return {};\n                },\n                accumulator: function (map, obj) {\n                    var result = predicate.call(ctx, obj);\n                    if (!map.hasOwnProperty(result)) {\n                        map[result] = [];\n                    }\n                    map[result].push(obj);\n                    return map;\n                }\n            });\n        };\n\n        var partitionByNumber = function (num) {\n            return pipeline.collect({\n                supplier: function () {\n                    return [];\n                },\n                accumulator: function (array, obj) {\n                    if (array.length === 0) {\n                        array.push([obj]);\n                        return array;\n                    }\n\n                    var partition = array[array.length - 1];\n                    if (partition.length === num) {\n                        array.push([obj]);\n                        return array;\n                    }\n\n                    partition.push(obj);\n                    return array;\n                }\n            });\n        };\n\n        terminal.joining = function (options) {\n            var prefix = \"\", suffix = \"\", delimiter = \"\";\n            if (options) {\n                prefix = options.prefix || prefix;\n                suffix = options.suffix || suffix;\n                delimiter = options.delimiter || delimiter;\n            }\n\n            return pipeline.collect({\n                supplier: function () {\n                    return \"\";\n                },\n                accumulator: function (str, obj, first) {\n                    var delim = first ? '' : delimiter;\n                    return str + delim + String(obj);\n                },\n                finisher: function (str) {\n                    return prefix + str + suffix;\n                }\n            });\n        };\n\n\n        //\n        // assert stream can only be consumed once by proxing all terminal operations\n        //\n\n        var consumed = false;\n\n        var assertNotConsumed = function () {\n            if (consumed) {\n                throw \"stream has already been operated upon\";\n            }\n        };\n\n        var terminalProxy = function (terminalFn) {\n            return function () {\n                try {\n                    assertNotConsumed();\n                    return terminalFn.apply(pipeline, arguments);\n                } finally {\n                    consumed = true;\n                }\n            };\n        };\n\n        for (var name in terminal) {\n            if (terminal.hasOwnProperty(name)) {\n                this[name] = terminalProxy(terminal[name]);\n            }\n        }\n    };\n\n\n    //\n    // Generic Pipeline operations\n    //\n\n    var StatelessOp = function (fn, flat, data) {\n        this.prev = null;\n        this.next = null;\n\n        this.advance = function () {\n            if (!isStashed() && this.prev === null) {\n                return eop;\n            }\n\n            if (!isStashed()) {\n                return this.prev.advance();\n            }\n\n            var obj = unstash();\n            if (this.next !== null) {\n                return this.next.pipe(obj);\n            }\n            return obj;\n        };\n\n        this.pipe = function (obj) {\n            var val = fn.call(ctx, obj);\n            stash(val, flat);\n\n            if (!isStashed()) {\n                return this.advance();\n            }\n\n            obj = unstash();\n            if (this.next !== null) {\n                return this.next.pipe(obj);\n            }\n            return obj;\n        };\n\n\n        // internal data buffering\n\n        var buffer = null,\n            flatten = false,    // if true buffer array will be iterated\n            keys = null,        // in case we iterate over object hash\n            origin = 0,         // current buffer index (if flatten)\n            fence = 0;          // max buffer size (if flatten)\n\n        var isStashed = function () {\n            if (buffer === null) {\n                return false;\n            }\n            if (flatten) {\n                return origin < fence;\n            }\n            return true;\n        };\n\n        var unstash = function () {\n            var bufferedVal;\n            if (!flatten) {\n                bufferedVal = buffer;\n                buffer = null;\n                return bufferedVal;\n            }\n\n            bufferedVal = nextBufferedVal();\n            origin++;\n            if (origin >= fence) {\n                buffer = null;\n                keys = null;\n                flatten = false;\n                origin = 0;\n                fence = 0;\n            }\n            return bufferedVal;\n        };\n\n        var nextBufferedVal = function () {\n            if (isArray(buffer)) {\n                return buffer[origin];\n            }\n            var key = keys[origin];\n            return buffer[key];\n        };\n\n        var stash = function (val, flat) {\n            buffer = val;\n            flatten = flat;\n\n            if (!flatten) {\n                return;\n            }\n\n            if (isArray(buffer)) {\n                fence = buffer.length;\n            } else if (isObject(buffer)) {\n                keys = Object.keys(buffer);\n                fence = keys.length;\n            }\n        };\n\n\n        if (data) {\n            stash(data, flat);\n        }\n    };\n\n    var StatefulOp = function (options) {\n        this.prev = null;\n        this.next = null;\n\n        var buffer = null, i = 0;\n\n        this.advance = function () {\n            var obj;\n            if (buffer === null) {\n                buffer = [];\n                while ((obj = this.prev.advance()) !== eop) {\n                    // obj will be added to buffer via this.pipe\n                    i++;\n                    if (options.voter) {\n                        var voted = options.voter.call(ctx, obj, i);\n                        if (!voted) {\n                            break;\n                        }\n                    }\n                }\n                if (options.finisher) {\n                    options.finisher.call(ctx, buffer);\n                }\n            }\n\n            if (buffer.length === 0) {\n                return eop;\n            }\n\n            obj = buffer.shift();\n            if (this.next !== null) {\n                return this.next.pipe(obj);\n            }\n\n            return obj;\n        };\n\n        this.pipe = function (obj) {\n            if (options.consumer) {\n                options.consumer.call(ctx, obj, i);\n            }\n\n            var filtered = true;\n            if (options.filter) {\n                filtered = options.filter.call(ctx, obj, i, buffer);\n            }\n            if (filtered) {\n                buffer.push(obj);\n            }\n        };\n    };\n\n\n    //\n    // Optional type\n    //\n\n    var Optional = function (val) {\n        this.isPresent = function () {\n            return val !== null && val !== undefined;\n        };\n\n        this.get = function () {\n            if (!this.isPresent()) {\n                throw \"optional value is not present\";\n            }\n            return val;\n        };\n\n        this.ifPresent = function (consumer) {\n            if (this.isPresent()) {\n                consumer.call(val, val);\n            }\n        };\n\n        this.orElse = function (otherVal) {\n            if (this.isPresent()) {\n                return val;\n            }\n            return otherVal;\n        };\n\n        this.orElseGet = function (supplier) {\n            if (this.isPresent()) {\n                return val;\n            }\n            return supplier.call(ctx);\n        };\n\n        this.orElseThrow = function (errorMsg) {\n            if (this.isPresent()) {\n                return val;\n            }\n            throw errorMsg;\n        };\n\n        this.filter = function (predicate) {\n            if (this.isPresent()) {\n                var filtered = predicate.call(ctx, val);\n                if (filtered) {\n                    return this;\n                }\n                return Optional.empty();\n            }\n            return this;\n        };\n\n        this.map = function (mapper) {\n            if (this.isPresent()) {\n                var mappedVal = mapper.call(ctx, val);\n                return Optional.ofNullable(mappedVal);\n            }\n            return this;\n        };\n\n        this.flatMap = function (flatMapper) {\n            if (this.isPresent()) {\n                return flatMapper.call(ctx, val);\n            }\n            return this;\n        };\n    };\n\n    Optional.of = function (val) {\n        if (val === null || val === undefined) {\n            throw \"value must be present\";\n        }\n        return new Optional(val);\n    };\n\n    Optional.ofNullable = function (val) {\n        return new Optional(val);\n    };\n\n    Optional.empty = function () {\n        return new Optional(undefined);\n    };\n\n\n    //\n    // Common stuff\n    //\n\n    var eop = \"END_OF_PIPE\",\n        ctx = {};\n\n    var defaultComparator = function (a, b) {\n        if (a === b) {\n            return 0;\n        }\n        return a > b ? 1 : -1;\n    };\n\n    var assertFn = function (obj, errorMsg) {\n        if (!isFunction(obj)) {\n            throw errorMsg;\n        }\n    };\n\n    var isFunction = function (obj) {\n        return typeof obj === 'function' || false;\n    };\n\n    var isNumber = function (obj) {\n        return Object.prototype.toString.call(obj) === '[object Number]';\n    };\n\n    var isArray = Array.isArray || function (obj) {\n            return Object.prototype.toString.call(obj) === '[object Array]';\n        };\n\n    var isObject = function (obj) {\n        return typeof obj === 'object' && !!obj;\n    };\n\n\n    //\n    // Stream function grants access to pipeline\n    //\n\n    var Stream = function (array) {\n        return new Pipeline(array);\n    };\n\n    Stream.range = function (startInclusive, endExclusive) {\n        var array = [];\n        for (var i = startInclusive; i < endExclusive; i++) {\n            array.push(i);\n        }\n        return Stream(array);\n    };\n\n    Stream.rangeClosed = function (startInclusive, endInclusive) {\n        return Stream.range(startInclusive, endInclusive + 1);\n    };\n\n\n    //\n    // public variables\n    //\n\n    Stream.VERSION = VERSION;\n\n    Stream.Optional = Optional;\n\n    var previousStream = window.Stream;\n\n    Stream.noConflict = function () {\n        window.Stream = previousStream;\n        return Stream;\n    };\n\n    window.Stream = Stream;\n\n}(window));"]}