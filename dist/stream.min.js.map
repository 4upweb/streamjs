{"version":3,"file":"stream.min.js","sources":["../src/stream.js"],"names":["root","this","VERSION","Pipeline","input","lastOp","pipeline","isFunction","GeneratorOp","call","ctx","StatelessOp","arg","add","op","prev","next","advance","filter","predicate","assertFn","filtered","map","mapper","flatMap","sorted","comparator","StatefulOp","finisher","array","sort","skip","num","obj","i","limit","voter","peek","consumer","distinct","indexOf","terminal","toArray","current","result","eop","push","findFirst","Optional","empty","ofNullable","findLast","last","forEach","fn","min","defaultComparator","max","sum","average","count","of","allMatch","match","anyMatch","noneMatch","collect","collector","identity","supplier","first","accumulator","reduce","arg0","arguments","arg1","reduceFirst","groupBy","keyMapper","key","hasOwnProperty","undefined","indexBy","mergeFunction","partitionBy","partitionByPredicate","isNumber","partitionByNumber","length","partition","joining","options","prefix","suffix","delimiter","str","delim","String","consumed","terminalProxy","terminalFn","apply","name","prototype","toString","val","pipe","flat","data","isStashed","unstash","stash","buffer","flatten","keys","origin","fence","bufferedVal","nextBufferedVal","isArray","isObject","Object","voted","shift","isPresent","get","ifPresent","orElse","otherVal","orElseGet","orElseThrow","errorMsg","mappedVal","flatMapper","a","b","Array","Stream","range","startInclusive","endExclusive","rangeClosed","endInclusive","args","slice","generate","iterate","seed","previousStream","window","noConflict","module","exports","define","amd"],"mappings":"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","sourcesContent":["/**\n * Stream.js 0.3.0\n * https://github.com/winterbe/streamjs\n * Copyright (c) 2014-2015 Benjamin Winterberg\n * Stream.js may be freely distributed under the MIT license.\n */\n(function () {\n    \"use strict\";\n\n\n    var root = this,\n        VERSION = \"0.3.0\";\n\n\n    //\n    // Internal Pipeline (doing all the work)\n    //\n\n    var Pipeline = function (input) {\n        var pipeline = this, lastOp;\n\n        // default op iterates over input elements\n        if (isFunction(input)) {\n            lastOp = new GeneratorOp(function () {\n                return input.call(ctx);\n            });\n        } else {\n            lastOp = new StatelessOp(function (arg) {\n                return arg;\n            }, true, input);\n        }\n\n        this.add = function (op) {\n            if (lastOp !== null) {\n                var prev = lastOp;\n                op.prev = prev;\n                prev.next = op;\n            }\n\n            lastOp = op;\n        };\n\n        this.next = function () {\n            return lastOp.advance();\n        };\n\n\n        //\n        // intermediate operations (stateless)\n        //\n\n        this.filter = function (predicate) {\n            assertFn(predicate, \"predicate function argument required for filter\");\n            this.add(new StatelessOp(function (arg) {\n                var filtered = predicate.call(ctx, arg);\n                if (filtered) {\n                    return arg;\n                } else {\n                    return null;\n                }\n            }));\n            return this;\n        };\n\n        this.map = function (mapper) {\n            assertFn(mapper, \"mapper function argument required for map\");\n            this.add(new StatelessOp(function (arg) {\n                return mapper.call(ctx, arg);\n            }));\n            return this;\n        };\n\n        this.flatMap = function (mapper) {\n            assertFn(mapper, \"mapper function argument required for flatMap\");\n            this.add(new StatelessOp(function (arg) {\n                return mapper.call(ctx, arg);\n            }, true));\n            return this;\n        };\n\n\n        //\n        // intermediate operations (stateful)\n        //\n\n        this.sorted = function (comparator) {\n            this.add(new StatefulOp({\n                finisher: function (array) {\n                    array.sort(comparator);\n                }\n            }));\n            return this;\n        };\n\n        this.skip = function (num) {\n            this.add(new StatefulOp({\n                filter: function (obj, i) {\n                    return i >= num;\n                }\n            }));\n            return this;\n        };\n\n        this.limit = function (num) {\n            this.add(new StatefulOp({\n                voter: function (obj, i) {\n                    return i < num;\n                }\n            }));\n            return this;\n        };\n\n        this.peek = function (consumer) {\n            this.add(new StatefulOp({\n                consumer: consumer\n            }));\n            return this;\n        };\n\n        this.distinct = function () {\n            this.add(new StatefulOp({\n                filter: function (obj, i, array) {\n                    return array.indexOf(obj) < 0;\n                }\n            }));\n            return this;\n        };\n\n\n        //\n        // terminal operations\n        //\n\n        var terminal = {};\n\n        terminal.toArray = function () {\n            var current, result = [];\n            while ((current = pipeline.next()) !== eop) {\n                result.push(current);\n            }\n            return result;\n        };\n\n        terminal.findFirst = function () {\n            var obj = pipeline.next();\n            if (obj === eop) {\n                return Optional.empty();\n            }\n            return Optional.ofNullable(obj);\n        };\n\n        terminal.findLast = function () {\n            var current, last;\n            while ((current = pipeline.next()) !== eop) {\n                last = current;\n            }\n            if (last === eop) {\n                return Optional.empty();\n            }\n            return Optional.ofNullable(last);\n        };\n\n        terminal.forEach = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                fn.call(ctx, current);\n            }\n        };\n\n        terminal.min = function (comparator) {\n            comparator = comparator || defaultComparator;\n            var current, result = null;\n            while ((current = pipeline.next()) !== eop) {\n                if (result === null || comparator.call(ctx, current, result) < 0) {\n                    result = current;\n                }\n            }\n            return Optional.ofNullable(result);\n        };\n\n        terminal.max = function (comparator) {\n            comparator = comparator || defaultComparator;\n            var current, result = null;\n            while ((current = pipeline.next()) !== eop) {\n                if (result === null || comparator.call(ctx, current, result) > 0) {\n                    result = current;\n                }\n            }\n            return Optional.ofNullable(result);\n        };\n\n        terminal.sum = function () {\n            var current, result = 0;\n            while ((current = pipeline.next()) !== eop) {\n                result += current;\n            }\n            return result;\n        };\n\n        terminal.average = function () {\n            var current, count = 0, sum = 0;\n            while ((current = pipeline.next()) !== eop) {\n                sum += current;\n                count++;\n            }\n            if (sum === 0 || count === 0) {\n                return Optional.empty();\n            }\n            return Optional.of(sum / count);\n        };\n\n        terminal.count = function () {\n            var current, result = 0;\n            while ((current = pipeline.next()) !== eop) {\n                result++;\n            }\n            return result;\n        };\n\n        terminal.allMatch = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                var match = fn.call(ctx, current);\n                if (!match) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        terminal.anyMatch = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                var match = fn.call(ctx, current);\n                if (match) {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        terminal.noneMatch = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                var match = fn.call(ctx, current);\n                if (match) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        terminal.collect = function (collector) {\n            var identity = collector.supplier.call(ctx);\n            var current, first = true;\n            while ((current = pipeline.next()) !== eop) {\n                identity = collector.accumulator.call(ctx, identity, current, first);\n                first = false;\n            }\n            if (collector.finisher) {\n                identity = collector.finisher.call(ctx, identity);\n            }\n            return identity;\n        };\n\n        terminal.reduce = function () {\n            var arg0 = arguments[0];\n            var arg1 = arguments[1];\n\n            if (arg1) {\n                return pipeline.collect({\n                    supplier: function () {\n                        return arg0;\n                    },\n                    accumulator: arg1\n                });\n            }\n\n            return reduceFirst(arg0);\n        };\n\n        var reduceFirst = function (accumulator) {\n            var current;\n\n            var identity = pipeline.next();\n            if (identity === eop) {\n                return Optional.empty();\n            }\n\n            while ((current = pipeline.next()) !== eop) {\n                identity = accumulator.call(ctx, identity, current);\n            }\n\n            return Optional.ofNullable(identity);\n        };\n\n        terminal.groupBy = function (keyMapper) {\n            return pipeline.collect({\n                supplier: function () {\n                    return {};\n                },\n                accumulator: function (map, obj) {\n                    var key = keyMapper.call(ctx, obj);\n                    if (!map.hasOwnProperty(key)) {\n                        map[key] = [];\n                    }\n\n                    if (map[key] === undefined) {\n                        map[key] = [];\n                    }\n\n                    map[key].push(obj);\n                    return map;\n                }\n            });\n        };\n\n        terminal.indexBy = function (keyMapper, mergeFunction) {\n            return pipeline.collect({\n                supplier: function () {\n                    return {};\n                },\n                accumulator: function (map, obj) {\n                    var key = keyMapper.call(ctx, obj);\n                    if (map.hasOwnProperty(key)) {\n                        if (!mergeFunction) {\n                            throw \"duplicate mapping found for key: \" + key;\n                        }\n                        map[key] = mergeFunction.call(ctx, map[key], obj);\n                        return map;\n                    }\n\n                    map[key] = obj;\n                    return map;\n                }\n            });\n        };\n\n        terminal.partitionBy = function () {\n            var arg0 = arguments[0];\n            if (isFunction(arg0)) {\n                return partitionByPredicate(arg0);\n            }\n            if (isNumber(arg0)) {\n                return partitionByNumber(arg0);\n            }\n            throw 'partitionBy requires argument of type function or number';\n        };\n\n        var partitionByPredicate = function (predicate) {\n            return pipeline.collect({\n                supplier: function () {\n                    return {};\n                },\n                accumulator: function (map, obj) {\n                    var result = predicate.call(ctx, obj);\n                    if (!map.hasOwnProperty(result)) {\n                        map[result] = [];\n                    }\n                    map[result].push(obj);\n                    return map;\n                }\n            });\n        };\n\n        var partitionByNumber = function (num) {\n            return pipeline.collect({\n                supplier: function () {\n                    return [];\n                },\n                accumulator: function (array, obj) {\n                    if (array.length === 0) {\n                        array.push([obj]);\n                        return array;\n                    }\n\n                    var partition = array[array.length - 1];\n                    if (partition.length === num) {\n                        array.push([obj]);\n                        return array;\n                    }\n\n                    partition.push(obj);\n                    return array;\n                }\n            });\n        };\n\n        terminal.joining = function (options) {\n            var prefix = \"\", suffix = \"\", delimiter = \"\";\n            if (options) {\n                prefix = options.prefix || prefix;\n                suffix = options.suffix || suffix;\n                delimiter = options.delimiter || delimiter;\n            }\n\n            return pipeline.collect({\n                supplier: function () {\n                    return \"\";\n                },\n                accumulator: function (str, obj, first) {\n                    var delim = first ? '' : delimiter;\n                    return str + delim + String(obj);\n                },\n                finisher: function (str) {\n                    return prefix + str + suffix;\n                }\n            });\n        };\n\n\n        //\n        // assert stream can only be consumed once by proxing all terminal operations\n        //\n\n        var consumed = false;\n\n        var terminalProxy = function (terminalFn) {\n            return function () {\n                try {\n                    if (consumed) {\n                        throw \"stream has already been operated upon\";\n                    }\n                    return terminalFn.apply(pipeline, arguments);\n                } finally {\n                    consumed = true;\n                }\n            };\n        };\n\n        for (var name in terminal) {\n            if (terminal.hasOwnProperty(name)) {\n                this[name] = terminalProxy(terminal[name]);\n            }\n        }\n    };\n\n    Pipeline.prototype.toString = function () {\n        return \"[object Stream]\";\n    };\n\n\n    //\n    // Generic Pipeline operations\n    //\n\n    var GeneratorOp = function (fn) {\n        this.prev = null;\n        this.next = null;\n\n        this.advance = function () {\n            var val = fn.call(ctx);\n            return this.next.pipe(val);\n        };\n    };\n\n    var StatelessOp = function (fn, flat, data) {\n        this.prev = null;\n        this.next = null;\n\n        this.advance = function () {\n            if (!isStashed() && this.prev === null) {\n                return eop;\n            }\n\n            if (!isStashed()) {\n                return this.prev.advance();\n            }\n\n            var obj = unstash();\n            if (this.next !== null) {\n                return this.next.pipe(obj);\n            }\n            return obj;\n        };\n\n        this.pipe = function (obj) {\n            var val = fn.call(ctx, obj);\n            stash(val, flat);\n\n            if (!isStashed()) {\n                return this.advance();\n            }\n\n            obj = unstash();\n            if (this.next !== null) {\n                return this.next.pipe(obj);\n            }\n            return obj;\n        };\n\n\n        // internal data buffering\n\n        var buffer = null,\n            flatten = false,    // if true buffer array will be iterated\n            keys = null,        // in case we iterate over object hash\n            origin = 0,         // current buffer index (if flatten)\n            fence = 0;          // max buffer size (if flatten)\n\n        var isStashed = function () {\n            if (buffer === null) {\n                return false;\n            }\n            if (flatten) {\n                return origin < fence;\n            }\n            return true;\n        };\n\n        var unstash = function () {\n            var bufferedVal;\n            if (!flatten) {\n                bufferedVal = buffer;\n                buffer = null;\n                return bufferedVal;\n            }\n\n            bufferedVal = nextBufferedVal();\n            origin++;\n            if (origin >= fence) {\n                buffer = null;\n                keys = null;\n                flatten = false;\n                origin = 0;\n                fence = 0;\n            }\n            return bufferedVal;\n        };\n\n        var nextBufferedVal = function () {\n            if (isArray(buffer)) {\n                return buffer[origin];\n            }\n            var key = keys[origin];\n            return buffer[key];\n        };\n\n        var stash = function (val, flat) {\n            buffer = val;\n            flatten = flat;\n\n            if (!flatten) {\n                return;\n            }\n\n            if (isArray(buffer)) {\n                fence = buffer.length;\n            } else if (isObject(buffer)) {\n                keys = Object.keys(buffer);\n                fence = keys.length;\n            }\n        };\n\n\n        if (data) {\n            stash(data, flat);\n        }\n    };\n\n    var StatefulOp = function (options) {\n        this.prev = null;\n        this.next = null;\n\n        var buffer = null, i = 0;\n\n        this.advance = function () {\n            var obj;\n            if (buffer === null) {\n                buffer = [];\n                while ((obj = this.prev.advance()) !== eop) {\n                    // obj will be added to buffer via this.pipe\n                    i++;\n                    if (options.voter) {\n                        var voted = options.voter.call(ctx, obj, i);\n                        if (!voted) {\n                            break;\n                        }\n                    }\n                }\n                if (options.finisher) {\n                    options.finisher.call(ctx, buffer);\n                }\n            }\n\n            if (buffer.length === 0) {\n                return eop;\n            }\n\n            obj = buffer.shift();\n            if (this.next !== null) {\n                return this.next.pipe(obj);\n            }\n\n            return obj;\n        };\n\n        this.pipe = function (obj) {\n            if (options.consumer) {\n                options.consumer.call(ctx, obj, i);\n            }\n\n            var filtered = true;\n            if (options.filter) {\n                filtered = options.filter.call(ctx, obj, i, buffer);\n            }\n            if (filtered) {\n                buffer.push(obj);\n            }\n        };\n    };\n\n\n    //\n    // Optional type\n    //\n\n    var Optional = function (val) {\n        this.isPresent = function () {\n            return val !== null && val !== undefined;\n        };\n\n        this.get = function () {\n            if (!this.isPresent()) {\n                throw \"optional value is not present\";\n            }\n            return val;\n        };\n\n        this.ifPresent = function (consumer) {\n            if (this.isPresent()) {\n                consumer.call(val, val);\n            }\n        };\n\n        this.orElse = function (otherVal) {\n            if (this.isPresent()) {\n                return val;\n            }\n            return otherVal;\n        };\n\n        this.orElseGet = function (supplier) {\n            if (this.isPresent()) {\n                return val;\n            }\n            return supplier.call(ctx);\n        };\n\n        this.orElseThrow = function (errorMsg) {\n            if (this.isPresent()) {\n                return val;\n            }\n            throw errorMsg;\n        };\n\n        this.filter = function (predicate) {\n            if (this.isPresent()) {\n                var filtered = predicate.call(ctx, val);\n                if (filtered) {\n                    return this;\n                }\n                return Optional.empty();\n            }\n            return this;\n        };\n\n        this.map = function (mapper) {\n            if (this.isPresent()) {\n                var mappedVal = mapper.call(ctx, val);\n                return Optional.ofNullable(mappedVal);\n            }\n            return this;\n        };\n\n        this.flatMap = function (flatMapper) {\n            if (this.isPresent()) {\n                return flatMapper.call(ctx, val);\n            }\n            return this;\n        };\n    };\n\n    Optional.prototype.toString = function () {\n        return \"[object Optional]\";\n    };\n\n    Optional.of = function (val) {\n        if (val === null || val === undefined) {\n            throw \"value must be present\";\n        }\n        return new Optional(val);\n    };\n\n    Optional.ofNullable = function (val) {\n        return new Optional(val);\n    };\n\n    Optional.empty = function () {\n        return new Optional(undefined);\n    };\n\n\n    //\n    // Common stuff\n    //\n\n    var eop = \"END_OF_PIPE\",\n        ctx = {};\n\n    var defaultComparator = function (a, b) {\n        if (a === b) {\n            return 0;\n        }\n        return a > b ? 1 : -1;\n    };\n\n    var assertFn = function (obj, errorMsg) {\n        if (!isFunction(obj)) {\n            throw errorMsg;\n        }\n    };\n\n    var isFunction = function (obj) {\n        return typeof obj === 'function' || false;\n    };\n\n    var isNumber = function (obj) {\n        return Object.prototype.toString.call(obj) === '[object Number]';\n    };\n\n    var isArray = Array.isArray || function (obj) {\n            return Object.prototype.toString.call(obj) === '[object Array]';\n        };\n\n    var isObject = function (obj) {\n        return typeof obj === 'object' && !!obj;\n    };\n\n\n    //\n    // Stream function grants access to pipeline\n    //\n\n    var Stream = function (input) {\n        return new Pipeline(input);\n    };\n\n    Stream.range = function (startInclusive, endExclusive) {\n        var array = [];\n        for (var i = startInclusive; i < endExclusive; i++) {\n            array.push(i);\n        }\n        return Stream(array);\n    };\n\n    Stream.rangeClosed = function (startInclusive, endInclusive) {\n        return Stream.range(startInclusive, endInclusive + 1);\n    };\n\n    Stream.of = function () {\n        // TODO passing arguments directly works in Chrome but fails with Phantom.js\n        var args = Array.prototype.slice.call(arguments);\n        return Stream(args);\n    };\n\n    Stream.generate = function (supplier) {\n        return Stream(supplier);\n    };\n\n    Stream.iterate = function (seed, fn) {\n        var first = true, current = seed;\n        return Stream(function () {\n            if (first) {\n                first = false;\n                return seed;\n            }\n            current = fn.call(ctx, current);\n            return current;\n        });\n    };\n\n\n    Stream.VERSION = VERSION;\n\n    Stream.Optional = Optional;\n\n    var previousStream = window.Stream;\n\n    Stream.noConflict = function () {\n        window.Stream = previousStream;\n        return Stream;\n    };\n\n\n    //\n    // expose Stream\n    //\n\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Stream;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define('streamjs', [], function () {\n            return Stream;\n        });\n    }\n    else {\n        root.Stream = Stream;\n    }\n\n}.call(this));"]}