{"version":3,"file":"stream.min.js","sources":["../src/stream.js"],"names":["window","VERSION","Pipeline","collection","pipeline","this","lastOp","StatelessOp","arg","add","op","prev","next","advance","filter","predicate","assertFn","filtered","call","ctx","map","mapper","flatMap","sorted","comparator","StatefulOp","finisher","array","sort","skip","num","obj","i","limit","voter","peek","consumer","distinct","indexOf","terminal","toArray","current","result","eop","push","findFirst","Optional","empty","ofNullable","findLast","last","forEach","fn","min","defaultComparator","max","sum","average","count","of","allMatch","match","anyMatch","noneMatch","collect","collector","identity","supplier","first","accumulator","reduce","arg0","arguments","arg1","reduceFirst","groupBy","keyMapper","key","hasOwnProperty","undefined","indexBy","mergeFunction","partitionBy","isFunction","partitionByPredicate","isNumber","partitionByNumber","length","partition","joining","options","prefix","suffix","delimiter","str","delim","String","consumed","assertNotConsumed","terminalProxy","terminalFn","apply","name","flat","data","isStashed","unstash","pipe","val","stash","buffer","flatten","keys","origin","fence","bufferedVal","nextBufferedVal","isArray","isObject","Object","prototype","toString","voted","shift","isPresent","get","ifPresent","orElse","otherVal","orElseGet","orElseThrow","errorMsg","mappedVal","flatMapper","a","b","Array","Stream","range","startInclusive","endExclusive","rangeClosed","endInclusive","previousStream","noConflict"],"mappings":"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","sourcesContent":["/**\n * Stream.js 0.3.0\n * https://github.com/winterbe/streamjs\n * Copyright (c) 2014-2015 Benjamin Winterberg\n * Stream.js may be freely distributed under the MIT license.\n */\n(function (window) {\n    \"use strict\";\n\n\n    var VERSION = \"0.3.0\";\n\n\n    //\n    // Internal Pipeline (doing all the work)\n    //\n\n    var Pipeline = function (collection) {\n        var pipeline = this;\n\n        // default op iterates over input array\n        var lastOp = new StatelessOp(function (arg) {\n            return arg;\n        }, true, collection);\n\n        this.add = function (op) {\n            if (lastOp !== null) {\n                var prev = lastOp;\n                op.prev = prev;\n                prev.next = op;\n            }\n\n            lastOp = op;\n        };\n\n        this.next = function () {\n            return lastOp.advance();\n        };\n\n\n        //\n        // intermediate operations (stateless)\n        //\n\n        this.filter = function (predicate) {\n            assertFn(predicate, \"predicate function argument required for filter\");\n            this.add(new StatelessOp(function (arg) {\n                var filtered = predicate.call(ctx, arg);\n                if (filtered) {\n                    return arg;\n                } else {\n                    return null;\n                }\n            }));\n            return this;\n        };\n\n        this.map = function (mapper) {\n            assertFn(mapper, \"mapper function argument required for map\");\n            this.add(new StatelessOp(function (arg) {\n                return mapper.call(ctx, arg);\n            }));\n            return this;\n        };\n\n        this.flatMap = function (mapper) {\n            assertFn(mapper, \"mapper function argument required for flatMap\");\n            this.add(new StatelessOp(function (arg) {\n                return mapper.call(ctx, arg);\n            }, true));\n            return this;\n        };\n\n\n        //\n        // intermediate operations (stateful)\n        //\n\n        this.sorted = function (comparator) {\n            this.add(new StatefulOp({\n                finisher: function (array) {\n                    array.sort(comparator);\n                }\n            }));\n            return this;\n        };\n\n        this.skip = function (num) {\n            this.add(new StatefulOp({\n                filter: function (obj, i) {\n                    return i >= num;\n                }\n            }));\n            return this;\n        };\n\n        this.limit = function (num) {\n            this.add(new StatefulOp({\n                voter: function (obj, i) {\n                    return i < num;\n                }\n            }));\n            return this;\n        };\n\n        this.peek = function (consumer) {\n            this.add(new StatefulOp({\n                consumer: consumer\n            }));\n            return this;\n        };\n\n        this.distinct = function () {\n            this.add(new StatefulOp({\n                filter: function (obj, i, array) {\n                    return array.indexOf(obj) < 0;\n                }\n            }));\n            return this;\n        };\n\n\n        //\n        // terminal operations\n        //\n\n        var terminal = {};\n\n        terminal.toArray = function () {\n            var current;\n            var result = [];\n            while ((current = pipeline.next()) !== eop) {\n                result.push(current);\n            }\n            return result;\n        };\n\n        terminal.findFirst = function () {\n            var obj = pipeline.next();\n            if (obj === eop) {\n                return Optional.empty();\n            }\n            return Optional.ofNullable(obj);\n        };\n\n        terminal.findLast = function () {\n            var current, last;\n            while ((current = pipeline.next()) !== eop) {\n                last = current;\n            }\n            if (last === eop) {\n                return Optional.empty();\n            }\n            return Optional.ofNullable(last);\n        };\n\n        terminal.forEach = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                fn.call(ctx, current);\n            }\n        };\n\n        terminal.min = function (comparator) {\n            comparator = comparator || defaultComparator;\n\n            var current, result = null;\n            while ((current = pipeline.next()) !== eop) {\n                if (result === null || comparator.call(ctx, current, result) < 0) {\n                    result = current;\n                }\n            }\n            return Optional.ofNullable(result);\n        };\n\n        terminal.max = function (comparator) {\n            comparator = comparator || defaultComparator;\n\n            var current, result = null;\n            while ((current = pipeline.next()) !== eop) {\n                if (result === null || comparator.call(ctx, current, result) > 0) {\n                    result = current;\n                }\n            }\n            return Optional.ofNullable(result);\n        };\n\n        terminal.sum = function () {\n            var current, result = 0;\n            while ((current = pipeline.next()) !== eop) {\n                result += current;\n            }\n            return result;\n        };\n\n        terminal.average = function () {\n            var current, count = 0, sum = 0;\n            while ((current = pipeline.next()) !== eop) {\n                sum += current;\n                count++;\n            }\n            if (sum === 0 || count === 0) {\n                return Optional.empty();\n            }\n            return Optional.of(sum / count);\n        };\n\n        terminal.count = function () {\n            var current, result = 0;\n            while ((current = pipeline.next()) !== eop) {\n                result++;\n            }\n            return result;\n        };\n\n        terminal.allMatch = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                var match = fn.call(ctx, current);\n                if (!match) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        terminal.anyMatch = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                var match = fn.call(ctx, current);\n                if (match) {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        terminal.noneMatch = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                var match = fn.call(ctx, current);\n                if (match) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        terminal.collect = function (collector) {\n            var identity = collector.supplier.call(ctx);\n            var current, first = true;\n            while ((current = pipeline.next()) !== eop) {\n                identity = collector.accumulator.call(ctx, identity, current, first);\n                first = false;\n            }\n            if (collector.finisher) {\n                identity = collector.finisher.call(ctx, identity);\n            }\n            return identity;\n        };\n\n        terminal.reduce = function () {\n            var arg0 = arguments[0];\n            var arg1 = arguments[1];\n\n            if (arg1) {\n                return pipeline.collect({\n                    supplier: function () {\n                        return arg0;\n                    },\n                    accumulator: arg1\n                });\n            }\n\n            return reduceFirst(arg0);\n        };\n\n        var reduceFirst = function (accumulator) {\n            var current;\n\n            var identity = pipeline.next();\n            if (identity === eop) {\n                return Optional.empty();\n            }\n\n            while ((current = pipeline.next()) !== eop) {\n                identity = accumulator.call(ctx, identity, current);\n            }\n\n            return Optional.ofNullable(identity);\n        };\n\n        terminal.groupBy = function (keyMapper) {\n            return pipeline.collect({\n                supplier: function () {\n                    return {};\n                },\n                accumulator: function (map, obj) {\n                    var key = keyMapper.call(ctx, obj);\n                    if (!map.hasOwnProperty(key)) {\n                        map[key] = [];\n                    }\n\n                    if (map[key] === undefined) {\n                        map[key] = [];\n                    }\n\n                    map[key].push(obj);\n                    return map;\n                }\n            });\n        };\n\n        terminal.indexBy = function (keyMapper, mergeFunction) {\n            return pipeline.collect({\n                supplier: function () {\n                    return {};\n                },\n                accumulator: function (map, obj) {\n                    var key = keyMapper.call(ctx, obj);\n                    if (map.hasOwnProperty(key)) {\n                        if (!mergeFunction) {\n                            throw \"duplicate mapping found for key: \" + key;\n                        }\n                        map[key] = mergeFunction.call(ctx, map[key], obj);\n                        return map;\n                    }\n\n                    map[key] = obj;\n                    return map;\n                }\n            });\n        };\n\n        terminal.partitionBy = function () {\n            var arg0 = arguments[0];\n            if (isFunction(arg0)) {\n                return partitionByPredicate(arg0);\n            }\n            if (isNumber(arg0)) {\n                return partitionByNumber(arg0);\n            }\n            throw 'partitionBy requires argument of type function or number';\n        };\n\n        var partitionByPredicate = function (predicate) {\n            return pipeline.collect({\n                supplier: function () {\n                    return {};\n                },\n                accumulator: function (map, obj) {\n                    var result = predicate.call(ctx, obj);\n                    if (!map.hasOwnProperty(result)) {\n                        map[result] = [];\n                    }\n                    map[result].push(obj);\n                    return map;\n                }\n            });\n        };\n\n        var partitionByNumber = function (num) {\n            return pipeline.collect({\n                supplier: function () {\n                    return [];\n                },\n                accumulator: function (array, obj) {\n                    if (array.length === 0) {\n                        array.push([obj]);\n                        return array;\n                    }\n\n                    var partition = array[array.length - 1];\n                    if (partition.length === num) {\n                        array.push([obj]);\n                        return array;\n                    }\n\n                    partition.push(obj);\n                    return array;\n                }\n            });\n        };\n\n        terminal.joining = function (options) {\n            var prefix = \"\", suffix = \"\", delimiter = \"\";\n            if (options) {\n                prefix = options.prefix || prefix;\n                suffix = options.suffix || suffix;\n                delimiter = options.delimiter || delimiter;\n            }\n\n            return pipeline.collect({\n                supplier: function () {\n                    return \"\";\n                },\n                accumulator: function (str, obj, first) {\n                    var delim = first ? '' : delimiter;\n                    return str + delim + String(obj);\n                },\n                finisher: function (str) {\n                    return prefix + str + suffix;\n                }\n            });\n        };\n\n\n        //\n        // assert stream can only be consumed once by proxing all terminal operations\n        //\n\n        var consumed = false;\n\n        var assertNotConsumed = function () {\n            if (consumed) {\n                throw \"stream has already been operated upon\";\n            }\n        };\n\n        var terminalProxy = function (terminalFn) {\n            return function () {\n                try {\n                    assertNotConsumed();\n                    return terminalFn.apply(pipeline, arguments);\n                } finally {\n                    consumed = true;\n                }\n            };\n        };\n\n        for (var name in terminal) {\n            if (terminal.hasOwnProperty(name)) {\n                this[name] = terminalProxy(terminal[name]);\n            }\n        }\n    };\n\n\n    //\n    // Generic Pipeline operations\n    //\n\n    var StatelessOp = function (fn, flat, data) {\n        this.prev = null;\n        this.next = null;\n\n        this.advance = function () {\n            if (!isStashed() && this.prev === null) {\n                return eop;\n            }\n\n            if (!isStashed()) {\n                return this.prev.advance();\n            }\n\n            var obj = unstash();\n            if (this.next !== null) {\n                return this.next.pipe(obj);\n            }\n            return obj;\n        };\n\n        this.pipe = function (obj) {\n            var val = fn.call(ctx, obj);\n            stash(val, flat);\n\n            if (!isStashed()) {\n                return this.advance();\n            }\n\n            obj = unstash();\n            if (this.next !== null) {\n                return this.next.pipe(obj);\n            }\n            return obj;\n        };\n\n\n        // internal data buffering\n\n        var buffer = null,\n            flatten = false,    // if true buffer array will be iterated\n            keys = null,        // in case we iterate over object hash\n            origin = 0,         // current buffer index (if flatten)\n            fence = 0;          // max buffer size (if flatten)\n\n        var isStashed = function () {\n            if (buffer === null) {\n                return false;\n            }\n            if (flatten) {\n                return origin < fence;\n            }\n            return true;\n        };\n\n        var unstash = function () {\n            var bufferedVal;\n            if (!flatten) {\n                bufferedVal = buffer;\n                buffer = null;\n                return bufferedVal;\n            }\n\n            bufferedVal = nextBufferedVal();\n            origin++;\n            if (origin >= fence) {\n                buffer = null;\n                keys = null;\n                flatten = false;\n                origin = 0;\n                fence = 0;\n            }\n            return bufferedVal;\n        };\n\n        var nextBufferedVal = function () {\n            if (isArray(buffer)) {\n                return buffer[origin];\n            }\n            var key = keys[origin];\n            return buffer[key];\n        };\n\n        var stash = function (val, flat) {\n            buffer = val;\n            flatten = flat;\n\n            if (!flatten) {\n                return;\n            }\n\n            if (isArray(buffer)) {\n                fence = buffer.length;\n            } else if (isObject(buffer)) {\n                keys = Object.keys(buffer);\n                fence = keys.length;\n            }\n        };\n\n\n        if (data) {\n            stash(data, flat);\n        }\n    };\n\n    Pipeline.prototype.toString = function () {\n        return \"[object Stream]\";\n    };\n\n    var StatefulOp = function (options) {\n        this.prev = null;\n        this.next = null;\n\n        var buffer = null, i = 0;\n\n        this.advance = function () {\n            var obj;\n            if (buffer === null) {\n                buffer = [];\n                while ((obj = this.prev.advance()) !== eop) {\n                    // obj will be added to buffer via this.pipe\n                    i++;\n                    if (options.voter) {\n                        var voted = options.voter.call(ctx, obj, i);\n                        if (!voted) {\n                            break;\n                        }\n                    }\n                }\n                if (options.finisher) {\n                    options.finisher.call(ctx, buffer);\n                }\n            }\n\n            if (buffer.length === 0) {\n                return eop;\n            }\n\n            obj = buffer.shift();\n            if (this.next !== null) {\n                return this.next.pipe(obj);\n            }\n\n            return obj;\n        };\n\n        this.pipe = function (obj) {\n            if (options.consumer) {\n                options.consumer.call(ctx, obj, i);\n            }\n\n            var filtered = true;\n            if (options.filter) {\n                filtered = options.filter.call(ctx, obj, i, buffer);\n            }\n            if (filtered) {\n                buffer.push(obj);\n            }\n        };\n    };\n\n\n    //\n    // Optional type\n    //\n\n    var Optional = function (val) {\n        this.isPresent = function () {\n            return val !== null && val !== undefined;\n        };\n\n        this.get = function () {\n            if (!this.isPresent()) {\n                throw \"optional value is not present\";\n            }\n            return val;\n        };\n\n        this.ifPresent = function (consumer) {\n            if (this.isPresent()) {\n                consumer.call(val, val);\n            }\n        };\n\n        this.orElse = function (otherVal) {\n            if (this.isPresent()) {\n                return val;\n            }\n            return otherVal;\n        };\n\n        this.orElseGet = function (supplier) {\n            if (this.isPresent()) {\n                return val;\n            }\n            return supplier.call(ctx);\n        };\n\n        this.orElseThrow = function (errorMsg) {\n            if (this.isPresent()) {\n                return val;\n            }\n            throw errorMsg;\n        };\n\n        this.filter = function (predicate) {\n            if (this.isPresent()) {\n                var filtered = predicate.call(ctx, val);\n                if (filtered) {\n                    return this;\n                }\n                return Optional.empty();\n            }\n            return this;\n        };\n\n        this.map = function (mapper) {\n            if (this.isPresent()) {\n                var mappedVal = mapper.call(ctx, val);\n                return Optional.ofNullable(mappedVal);\n            }\n            return this;\n        };\n\n        this.flatMap = function (flatMapper) {\n            if (this.isPresent()) {\n                return flatMapper.call(ctx, val);\n            }\n            return this;\n        };\n    };\n\n    Optional.prototype.toString = function () {\n        return \"[object Optional]\";\n    };\n\n    Optional.of = function (val) {\n        if (val === null || val === undefined) {\n            throw \"value must be present\";\n        }\n        return new Optional(val);\n    };\n\n    Optional.ofNullable = function (val) {\n        return new Optional(val);\n    };\n\n    Optional.empty = function () {\n        return new Optional(undefined);\n    };\n\n\n    //\n    // Common stuff\n    //\n\n    var eop = \"END_OF_PIPE\",\n        ctx = {};\n\n    var defaultComparator = function (a, b) {\n        if (a === b) {\n            return 0;\n        }\n        return a > b ? 1 : -1;\n    };\n\n    var assertFn = function (obj, errorMsg) {\n        if (!isFunction(obj)) {\n            throw errorMsg;\n        }\n    };\n\n    var isFunction = function (obj) {\n        return typeof obj === 'function' || false;\n    };\n\n    var isNumber = function (obj) {\n        return Object.prototype.toString.call(obj) === '[object Number]';\n    };\n\n    var isArray = Array.isArray || function (obj) {\n            return Object.prototype.toString.call(obj) === '[object Array]';\n        };\n\n    var isObject = function (obj) {\n        return typeof obj === 'object' && !!obj;\n    };\n\n\n    //\n    // Stream function grants access to pipeline\n    //\n\n    var Stream = function (array) {\n        return new Pipeline(array);\n    };\n\n    Stream.range = function (startInclusive, endExclusive) {\n        var array = [];\n        for (var i = startInclusive; i < endExclusive; i++) {\n            array.push(i);\n        }\n        return Stream(array);\n    };\n\n    Stream.rangeClosed = function (startInclusive, endInclusive) {\n        return Stream.range(startInclusive, endInclusive + 1);\n    };\n\n\n    //\n    // public variables\n    //\n\n    Stream.VERSION = VERSION;\n\n    Stream.Optional = Optional;\n\n    var previousStream = window.Stream;\n\n    Stream.noConflict = function () {\n        window.Stream = previousStream;\n        return Stream;\n    };\n\n    window.Stream = Stream;\n\n}(window));"]}