{"version":3,"file":"stream.min.js","sources":["../src/stream.js"],"names":["window","VERSION","Pipeline","array","pipeline","this","lastOp","StatelessOp","arg","add","op","prev","next","advance","filter","predicate","assertFn","filtered","call","ctx","map","mapper","flatMap","sorted","comparator","StatefulOp","finisher","sort","skip","num","obj","i","limit","voter","peek","consumer","distinct","indexOf","terminal","toArray","current","result","eop","push","findFirst","Optional","empty","ofNullable","findLast","last","forEach","fn","min","defaultComparator","max","sum","average","count","allMatch","match","anyMatch","noneMatch","collect","collector","identity","supplier","first","accumulator","reduce","arg0","arguments","arg1","reduceFirst","groupBy","keyMapper","key","hasOwnProperty","undefined","indexBy","mergeFunction","partitionBy","isFunction","partitionByPredicate","isNumber","partitionByNumber","length","partition","joining","options","prefix","suffix","delimiter","str","delim","String","consumed","assertNotConsumed","terminalProxy","terminalFn","apply","name","flat","data","isStashed","unstash","pipe","val","stash","buffer","flatten","origin","fence","bufferedVal","voted","shift","isPresent","get","ifPresent","orElse","otherVal","orElseGet","orElseThrow","errorMsg","mappedVal","flatMapper","of","a","b","Object","prototype","toString","Stream","range","startInclusive","endExclusive","rangeClosed","endInclusive","previousStream","noConflict"],"mappings":"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","sourcesContent":["/**\n * Stream.js 0.1.0\n * https://github.com/winterbe/streamjs\n * Copyright (c) 2014-2015 Benjamin Winterberg\n * Stream.js may be freely distributed under the MIT license.\n */\n(function (window) {\n    \"use strict\";\n\n\n    var VERSION = \"0.1.0\";\n\n\n    //\n    // Internal Pipeline (doing all the work)\n    //\n\n    var Pipeline = function (array) {\n        var pipeline = this;\n\n        // default op iterates over input array\n        var lastOp = new StatelessOp(function (arg) {\n            return arg;\n        }, true, array);\n\n        this.add = function (op) {\n            if (lastOp !== null) {\n                var prev = lastOp;\n                op.prev = prev;\n                prev.next = op;\n            }\n\n            lastOp = op;\n        };\n\n        this.next = function () {\n            return lastOp.advance();\n        };\n\n\n        //\n        // intermediate operations (stateless)\n        //\n\n        this.filter = function (predicate) {\n            assertFn(predicate, \"predicate function argument required for filter\");\n            this.add(new StatelessOp(function (arg) {\n                var filtered = predicate.call(ctx, arg);\n                if (filtered) {\n                    return arg;\n                } else {\n                    return null;\n                }\n            }));\n            return this;\n        };\n\n        this.map = function (mapper) {\n            assertFn(mapper, \"mapper function argument required for map\");\n            this.add(new StatelessOp(function (arg) {\n                return mapper.call(ctx, arg);\n            }));\n            return this;\n        };\n\n        this.flatMap = function (mapper) {\n            assertFn(mapper, \"mapper function argument required for flatMap\");\n            this.add(new StatelessOp(function (arg) {\n                return mapper.call(ctx, arg);\n            }, true));\n            return this;\n        };\n\n\n        //\n        // intermediate operations (stateful)\n        //\n\n        this.sorted = function (comparator) {\n            this.add(new StatefulOp({\n                finisher: function (array) {\n                    array.sort(comparator);\n                }\n            }));\n            return this;\n        };\n\n        this.skip = function (num) {\n            this.add(new StatefulOp({\n                filter: function (obj, i) {\n                    return i >= num;\n                }\n            }));\n            return this;\n        };\n\n        this.limit = function (num) {\n            this.add(new StatefulOp({\n                voter: function (obj, i) {\n                    return i < num;\n                }\n            }));\n            return this;\n        };\n\n        this.peek = function (consumer) {\n            this.add(new StatefulOp({\n                consumer: consumer\n            }));\n            return this;\n        };\n\n        this.distinct = function () {\n            this.add(new StatefulOp({\n                filter: function (obj, i, array) {\n                    return array.indexOf(obj) < 0;\n                }\n            }));\n            return this;\n        };\n\n\n        //\n        // terminal operations\n        //\n\n        var terminal = {};\n\n        terminal.toArray = function () {\n            var current;\n            var result = [];\n            while ((current = pipeline.next()) !== eop) {\n                result.push(current);\n            }\n            return result;\n        };\n\n        terminal.findFirst = function () {\n            var obj = pipeline.next();\n            if (obj === eop) {\n                return Optional.empty();\n            }\n            return Optional.ofNullable(obj);\n        };\n\n        terminal.findLast = function () {\n            var current, last;\n            while ((current = pipeline.next()) !== eop) {\n                last = current;\n            }\n            if (last === eop) {\n                return Optional.empty();\n            }\n            return Optional.ofNullable(last);\n        };\n\n        terminal.forEach = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                fn.call(ctx, current);\n            }\n        };\n\n        terminal.min = function (comparator) {\n            comparator = comparator || defaultComparator;\n\n            var current, result = null;\n            while ((current = pipeline.next()) !== eop) {\n                if (result === null || comparator.call(ctx, current, result) < 0) {\n                    result = current;\n                }\n            }\n            return result;\n        };\n\n        terminal.max = function (comparator) {\n            comparator = comparator || defaultComparator;\n\n            var current, result = null;\n            while ((current = pipeline.next()) !== eop) {\n                if (result === null || comparator.call(ctx, current, result) > 0) {\n                    result = current;\n                }\n            }\n            return result;\n        };\n\n        terminal.sum = function () {\n            var current, result = 0;\n            while ((current = pipeline.next()) !== eop) {\n                result += current;\n            }\n            return result;\n        };\n\n        terminal.average = function () {\n            var current, count = 0, sum = 0;\n            while ((current = pipeline.next()) !== eop) {\n                sum += current;\n                count++;\n            }\n            return sum / count;\n        };\n\n        terminal.count = function () {\n            var current, result = 0;\n            while ((current = pipeline.next()) !== eop) {\n                result++;\n            }\n            return result;\n        };\n\n        terminal.allMatch = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                var match = fn.call(ctx, current);\n                if (!match) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        terminal.anyMatch = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                var match = fn.call(ctx, current);\n                if (match) {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        terminal.noneMatch = function (fn) {\n            var current;\n            while ((current = pipeline.next()) !== eop) {\n                var match = fn.call(ctx, current);\n                if (match) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        terminal.collect = function (collector) {\n            var identity = collector.supplier.call(ctx);\n            var current, first = true;\n            while ((current = pipeline.next()) !== eop) {\n                identity = collector.accumulator.call(ctx, identity, current, first);\n                first = false;\n            }\n            if (collector.finisher) {\n                identity = collector.finisher.call(ctx, identity);\n            }\n            return identity;\n        };\n\n        terminal.reduce = function () {\n            var arg0 = arguments[0];\n            var arg1 = arguments[1];\n\n            if (arg1) {\n                return pipeline.collect({\n                    supplier: function () {\n                        return arg0;\n                    },\n                    accumulator: arg1\n                });\n            }\n\n            return reduceFirst(arg0);\n        };\n\n        var reduceFirst = function (accumulator) {\n            var current;\n\n            var identity = pipeline.next();\n            if (identity === eop) {\n                return Optional.empty();\n            }\n\n            while ((current = pipeline.next()) !== eop) {\n                identity = accumulator.call(ctx, identity, current);\n            }\n\n            return Optional.ofNullable(identity);\n        };\n\n        terminal.groupBy = function (keyMapper, map) {\n            return pipeline.collect({\n                supplier: function () {\n                    return map || {};\n                },\n                accumulator: function (map, obj) {\n                    var key = keyMapper.call(ctx, obj);\n                    if (!map.hasOwnProperty(key)) {\n                        map[key] = [];\n                    }\n\n                    if (map[key] === undefined) {\n                        map[key] = [];\n                    }\n\n                    map[key].push(obj);\n                    return map;\n                }\n            });\n        };\n\n        terminal.indexBy = function (keyMapper, mergeFunction, map) {\n            return pipeline.collect({\n                supplier: function () {\n                    return map || {};\n                },\n                accumulator: function (map, obj) {\n                    var key = keyMapper.call(ctx, obj);\n                    if (map.hasOwnProperty(key)) {\n                        if (!mergeFunction) {\n                            throw \"duplicate mapping found for key: \" + key;\n                        }\n                        map[key] = mergeFunction.call(ctx, map[key], obj);\n                        return map;\n                    }\n\n                    map[key] = obj;\n                    return map;\n                }\n            });\n        };\n\n        terminal.partitionBy = function () {\n            var arg0 = arguments[0];\n            if (isFunction(arg0)) {\n                return partitionByPredicate(arg0);\n            }\n            if (isNumber(arg0)) {\n                return partitionByNumber(arg0);\n            }\n            throw 'partitionBy requires argument of type function or number';\n        };\n\n        var partitionByPredicate = function (predicate) {\n            return pipeline.collect({\n                supplier: function () {\n                    return {};\n                },\n                accumulator: function (map, obj) {\n                    var result = predicate.call(ctx, obj);\n                    if (!map.hasOwnProperty(result)) {\n                        map[result] = [];\n                    }\n                    map[result].push(obj);\n                    return map;\n                }\n            });\n        };\n\n        var partitionByNumber = function (num) {\n            return pipeline.collect({\n                supplier: function () {\n                    return [];\n                },\n                accumulator: function (array, obj) {\n                    if (array.length === 0) {\n                        array.push([obj]);\n                        return array;\n                    }\n\n                    var partition = array[array.length - 1];\n                    if (partition.length === num) {\n                        array.push([obj]);\n                        return array;\n                    }\n\n                    partition.push(obj);\n                    return array;\n                }\n            });\n        };\n\n        terminal.joining = function (options) {\n            var prefix = \"\", suffix = \"\", delimiter = \"\";\n            if (options) {\n                prefix = options.prefix || prefix;\n                suffix = options.suffix || suffix;\n                delimiter = options.delimiter || delimiter;\n            }\n\n            return pipeline.collect({\n                supplier: function () {\n                    return \"\";\n                },\n                accumulator: function (str, obj, first) {\n                    var delim = first ? '' : delimiter;\n                    return str + delim + String(obj);\n                },\n                finisher: function (str) {\n                    return prefix + str + suffix;\n                }\n            });\n        };\n\n\n        //\n        // assert stream can only be consumed once by proxing all terminal operations\n        //\n\n        var consumed = false;\n\n        var assertNotConsumed = function () {\n            if (consumed) {\n                throw \"stream has already been operated upon\";\n            }\n        };\n\n        var terminalProxy = function (terminalFn) {\n            return function () {\n                try {\n                    assertNotConsumed();\n                    return terminalFn.apply(pipeline, arguments);\n                } finally {\n                    consumed = true;\n                }\n            };\n        };\n\n        for (var name in terminal) {\n            if (terminal.hasOwnProperty(name)) {\n                this[name] = terminalProxy(terminal[name]);\n            }\n        }\n    };\n\n\n    //\n    // Generic Pipeline operations\n    //\n\n    var StatelessOp = function (fn, flat, data) {\n        this.prev = null;\n        this.next = null;\n\n        this.advance = function () {\n            if (!isStashed() && this.prev === null) {\n                return eop;\n            }\n\n            if (!isStashed()) {\n                return this.prev.advance();\n            }\n\n            var obj = unstash();\n            if (this.next !== null) {\n                return this.next.pipe(obj);\n            }\n            return obj;\n        };\n\n        this.pipe = function (obj) {\n            var val = fn.call(ctx, obj);\n            stash(val, flat);\n\n            if (!isStashed()) {\n                return this.advance();\n            }\n\n            obj = unstash();\n            if (this.next !== null) {\n                return this.next.pipe(obj);\n            }\n            return obj;\n        };\n\n\n        // internal data buffering\n\n        var buffer = null,\n            flatten = false,    // if true buffer array will be iterated\n            origin = 0,         // current buffer index (if flatten)\n            fence = 0;          // max buffer size (if flatten)\n\n        var isStashed = function () {\n            if (buffer === null) {\n                return false;\n            }\n            if (flatten) {\n                return origin < fence;\n            }\n            return true;\n        };\n\n        var unstash = function () {\n            var bufferedVal;\n            if (!flatten) {\n                bufferedVal = buffer;\n                buffer = null;\n                return bufferedVal;\n            }\n\n            bufferedVal = buffer[origin];\n            origin++;\n            if (origin >= fence) {\n                buffer = null;\n                flatten = false;\n                origin = 0;\n                fence = 0;\n            }\n            return bufferedVal;\n        };\n\n        var stash = function (val, flat) {\n            buffer = val;\n            flatten = flat;\n            if (flatten) {\n                fence = buffer.length;\n            }\n        };\n\n\n        if (data) {\n            stash(data, flat);\n        }\n    };\n\n    var StatefulOp = function (options) {\n        this.prev = null;\n        this.next = null;\n\n        var buffer = null, i = 0;\n\n        this.advance = function () {\n            var obj;\n            if (buffer === null) {\n                buffer = [];\n                while ((obj = this.prev.advance()) !== eop) {\n                    // obj will be added to buffer via this.pipe\n                    i++;\n                    if (options.voter) {\n                        var voted = options.voter.call(ctx, obj, i);\n                        if (!voted) {\n                            break;\n                        }\n                    }\n                }\n                if (options.finisher) {\n                    options.finisher.call(ctx, buffer);\n                }\n            }\n\n            if (buffer.length === 0) {\n                return eop;\n            }\n\n            obj = buffer.shift();\n            if (this.next !== null) {\n                return this.next.pipe(obj);\n            }\n\n            return obj;\n        };\n\n        this.pipe = function (obj) {\n            if (options.consumer) {\n                options.consumer.call(ctx, obj, i);\n            }\n\n            var filtered = true;\n            if (options.filter) {\n                filtered = options.filter.call(ctx, obj, i, buffer);\n            }\n            if (filtered) {\n                buffer.push(obj);\n            }\n        };\n    };\n\n\n    //\n    // Optional type\n    //\n\n    var Optional = function (val) {\n        this.isPresent = function () {\n            return val !== null && val !== undefined;\n        };\n\n        this.get = function () {\n            if (!this.isPresent()) {\n                throw \"optional value is not present\";\n            }\n            return val;\n        };\n\n        this.ifPresent = function (consumer) {\n            if (this.isPresent()) {\n                consumer.call(val, val);\n            }\n        };\n\n        this.orElse = function (otherVal) {\n            if (this.isPresent()) {\n                return val;\n            }\n            return otherVal;\n        };\n\n        this.orElseGet = function (supplier) {\n            if (this.isPresent()) {\n                return val;\n            }\n            return supplier.call(ctx);\n        };\n\n        this.orElseThrow = function (errorMsg) {\n            if (this.isPresent()) {\n                return val;\n            }\n            throw errorMsg;\n        };\n\n        this.filter = function (predicate) {\n            if (this.isPresent()) {\n                var filtered = predicate.call(ctx, val);\n                if (filtered) {\n                    return this;\n                }\n                return Optional.empty();\n            }\n            return this;\n        };\n\n        this.map = function (mapper) {\n            if (this.isPresent()) {\n                var mappedVal = mapper.call(ctx, val);\n                return Optional.ofNullable(mappedVal);\n            }\n            return this;\n        };\n\n        this.flatMap = function (flatMapper) {\n            if (this.isPresent()) {\n                return flatMapper.call(ctx, val);\n            }\n            return this;\n        };\n    };\n\n    Optional.of = function (val) {\n        if (val === null || val === undefined) {\n            throw \"value must be present\";\n        }\n        return new Optional(val);\n    };\n\n    Optional.ofNullable = function (val) {\n        return new Optional(val);\n    };\n\n    Optional.empty = function () {\n        return new Optional(undefined);\n    };\n\n\n    //\n    // Common stuff\n    //\n\n    var eop = \"END_OF_PIPE\",\n        ctx = {};\n\n    var defaultComparator = function (a, b) {\n        if (a === b) {\n            return 0;\n        }\n        return a > b ? 1 : -1;\n    };\n\n    var assertFn = function (obj, errorMsg) {\n        if (!isFunction(obj)) {\n            throw errorMsg;\n        }\n    };\n\n    var isFunction = function (obj) {\n        return typeof obj === 'function' || false;\n    };\n\n    var isNumber = function (obj) {\n        return Object.prototype.toString.call(obj) === '[object Number]';\n    };\n\n\n    //\n    // Stream function grants access to pipeline\n    //\n\n    var Stream = function (array) {\n        return new Pipeline(array);\n    };\n\n    Stream.range = function (startInclusive, endExclusive) {\n        var array = [];\n        for (var i = startInclusive; i < endExclusive; i++) {\n            array.push(i);\n        }\n        return Stream(array);\n    };\n\n    Stream.rangeClosed = function (startInclusive, endInclusive) {\n        return Stream.range(startInclusive, endInclusive + 1);\n    };\n\n\n    //\n    // public variables\n    //\n\n    Stream.VERSION = VERSION;\n\n    Stream.Optional = Optional;\n\n    var previousStream = window.Stream;\n\n    Stream.noConflict = function () {\n        window.Stream = previousStream;\n        return Stream;\n    };\n\n    window.Stream = Stream;\n\n}(window));"]}