{"name":"Stream.js","tagline":"Object Streaming Pipeline for JavaScript - inspired by the Java 8 Streams API","body":"### Example\r\n\r\n```js\r\nStream([5, 9, 2, 4, 8, 1])\r\n   .filter(function (num) {\r\n      return num % 2 === 1;\r\n   })\r\n   .sorted()\r\n   .map(function (num) {\r\n      return \"odd\" + num;\r\n   })\r\n   .toArray();\r\n```\r\n\r\n<p align=\"center\">\r\n   <i>Follow on <a href=\"https://twitter.com/benontherun\">Twitter</a> for Updates</i>\r\n</p>\r\n\r\n# Getting started\r\n\r\nStream.js is based on ECMAScript 5 and works in all modern browsers. You can install Stream.js manually by downloading the [latest release](https://github.com/winterbe/streamjs/releases) from GitHub. The `src` folder contains the minified script and a source map file for debugging. Alternatively you can install Stream.js with [Bower](http://bower.io/):\r\n\r\n```bash\r\n$ bower install streamjs\r\n```\r\n\r\n# How Streams work\r\n\r\nStream.js defines a single function `Stream` to create new streams from different input collections like _arrays_, _maps_ or _number ranges_:\r\n\r\n```js\r\nStream([1, 2, 3]);\r\nStream({a: 1, b: 2, c: 3});\r\nStream.of(1, 2, 3);\r\nStream.range(1, 4);\r\n```\r\n\r\nStreams are monadic types with a bunch of useful operations. Those functions can be chained one after another to make complex computations upon the input elements. Operations are either *intermediate* or *terminal*. Intermediate operations are lazy and return the stream itself to enable method chaining. Terminal operations return a single result (or nothing at all). Some terminal operations return a special monadic `Optional` type which is described later.\r\n\r\nStreams are not limited to finite data sources like collections. You can also create *infinite* streams of elements by utilizing generator or iterator functions.\r\n\r\n```js\r\nStream.generate(function() {\r\n   return 1337 * Math.random();\r\n);\r\n```\r\n\r\n```js\r\nStream.iterate(1, function (seed) {\r\n   return seed * 2;\r\n});\r\n```\r\n\r\n# Why Stream.js?\r\n\r\nWhat's so different between Stream.js and other functional libraries like Underscore.js?\r\n\r\nStream.js is built around a lazily evaluated operation pipeline. Instead of consecutively performing each operation on the whole input collection, objects are passed vertically and one by one upon the chain. Interim results will _not_ be stored in internal collections (except for some stateful operations like `sorted`). Instead objects are directly piped into the resulting object as specified by the terminal operation. This results in **minimized memory consumption** and internal state.\r\n\r\nStream operations are lazily evaluated to avoid examining all of the input data when it's not necessary. Streams always perform the minimal amount of operations to gain results. E.g. in a `filter - map - findFirst` stream you don't have to filter and map the whole data. Instead `map` and `findFirst` will only executed once before returning the single result. This results in **increased performance** when operation upon large amounts of input elements.\r\n\r\n```js\r\nStream([1, 2, 3, 4])\r\n   .filter(function(num) {   // called twice\r\n      return num % 2 === 0;\r\n   })\r\n   .map(function(even) {     // called once\r\n      return \"even\" + even;\r\n   })\r\n   .findFirst();             // called once\r\n```\r\n\r\n# API Doc\r\n\r\n## Constructors\r\n\r\nThe following constructor functions can be used to create different kind of streams.\r\n\r\n##### Stream(collection)\r\n\r\nReturns a new stream for the given collection. Collection can either be an array or an object hash (map).\r\n\r\n##### Stream(string)\r\n\r\nReturns a new stream for the given string. The string will be splitted by characters.\r\n\r\n##### Stream.of(args...)\r\n\r\nReturns a new stream for the given arguments.\r\n\r\n##### Stream.empty\r\n\r\nReturns a new empty stream.\r\n\r\n##### Stream.range(startInclusive, endExclusive)\r\n\r\nReturns a new stream for the given number range.\r\n\r\n##### Stream.rangeClosed(startInclusive, endInclusive)\r\n\r\nReturns a new stream for the given number range.\r\n\r\n##### Stream.generate(supplier)\r\n\r\nReturns a new infinite stream. The elements of the stream are generated by the given supplier function.\r\n\r\n##### Stream.iterate(seed, fn)\r\n\r\nReturns a new infinite stream. The elements of the stream are generated by utilizing the given iterator function, starting with `seed` at n=0, then calling fn(seed) for n=1, fn(fn(seed)) for n=2 etc.\r\n\r\n## Intermediate Operations\r\n\r\nIntermediate operations all return a stream, thus enabling you to chain multiple operations one after another without using semicolons.\r\n\r\n##### filter(predicate)\r\n\r\nFilters the elements of the stream to match the given predicate function and returns the stream.\r\n\r\n##### map(mappingFn)\r\n\r\nApplies the given mapping function to each element of the stream and returns the stream.\r\n\r\n##### flatMap(mappingFn)\r\n\r\nApplies the given mapping function to each element of the stream and flattens the results by replacing each element with the contents of the element in case of collections, then returns the stream.\r\n\r\n##### sorted()\r\n\r\nSorts the elements of the stream according to the natural order and returns the stream.\r\n\r\nAlias: `sort`\r\n\r\n##### sorted(comparator)\r\n\r\nSorts the elements of the stream according to the given comparator and returns the stream.\r\n\r\nAlias: `sort`\r\n\r\n##### distinct()\r\n\r\nReturns the stream consisting of the distinct elements of this stream.\r\n\r\n##### limit(maxSize)\r\n\r\nTruncates the elements of the stream to be no longer than `maxSize` and returns the stream.\r\n\r\n##### skip(n)\r\n\r\nDiscards the first `n` elements and returns the stream.\r\n\r\n##### peek(consumer)\r\n\r\nPerforms the consumer function for each element and returns the stream.\r\n\r\n## Terminal Operations\r\n\r\nTerminal operations return a result (or nothing), so each streaming pipeline consists of 0 to n intermediate operations followed by exactly one terminal operation.\r\n\r\n##### toArray()\r\n\r\nReturns an array containing the elements of the stream.\r\n\r\nAlias: `toList`\r\n\r\n##### forEach(consumer)\r\n\r\nPerforms the consumer function for each element of the stream.\r\n\r\nAlias: `each`\r\n\r\n##### findFirst()\r\n\r\nReturns an `Optional` wrapping the first element of the stream or `Optional.empty()` if the stream is empty.\r\n\r\nAlias: `findAny`\r\n\r\n##### min()\r\n\r\nReturns an `Optional` wrapping the minimum element of the stream (according the natural order) or `Optional.empty()` if the stream is empty.\r\n\r\n##### min(comparator)\r\n\r\nReturns an `Optional` wrapping the minimum element of the stream (according the given comparator function) or `Optional.empty()` if the stream is empty.\r\n\r\n##### max()\r\n\r\nReturns an `Optional` wrapping the maximum element of the stream (according the natural order) or `Optional.empty()` if the stream is empty.\r\n\r\n##### max(comparator)\r\n\r\nReturns an `Optional` wrapping the maximum element of the stream (according the given comparator function) or `Optional.empty()` if the stream is empty.\r\n\r\n##### sum()\r\n\r\nReturns the sum of all elements in this stream.\r\n\r\n##### average()\r\n\r\nReturns an `Optional` wrapping the arithmetic mean of all elements of this stream or `Optional.empty()` if the stream is empty.\r\n\r\nAlias: `avg`\r\n\r\n##### count()\r\n\r\nReturns the number of elements of the stream.\r\n\r\nAlias: `size`\r\n\r\n##### allMatch(predicate)\r\n\r\nReturns whether all elements of the stream match the given predicate function.\r\n\r\n##### anyMatch(predicate)\r\n\r\nReturns whether any element of the stream matches the given predicate function.\r\n\r\n##### noneMatch(predicate)\r\n\r\nReturns whether no element of the stream matches the given predicate function.\r\n\r\n##### collect(collector)\r\n\r\nPerforms a generalized reduction operation denoted by the given collector and returns the reduced value. A collector consists of a supplier function, an accumulator function and an optional finisher function.\r\n\r\n##### reduce(identity, accumulator)\r\n\r\nPerforms a reduction operation using the provided `identity` object as initial value and the accumulator function and returns the reduced value.\r\n\r\n##### reduce(accumulator)\r\n\r\nPerforms a reduction operation using the first element of the stream as as initial value and the accumulator function and returns the reduced value wrapped as `Optional`.\r\n\r\n##### groupingBy(keyMapper)\r\n\r\nGroups all elements of the stream by applying the given keyMapper function and returns an object map, assigning an array value for each key.\r\n\r\nAlias: `groupBy`\r\n\r\n##### toMap(keyMapper, mergeFunction)\r\n\r\nGroups all elements of the stream by applying the given keyMapper function and returns an object map, assigning a single value for each key. Multiple values for the same key will be merged using the given merge function.\r\n\r\nAlias: `indexBy`\r\n\r\n##### partitioningBy(predicate)\r\n\r\nGroups all elements of the stream by the results of applying the given predicate to each element of the stream, returning an object with two keys `true` and `false`.\r\n\r\nAlias: `partitionBy`\r\n\r\n##### partitioningBy(size)\r\n\r\nGroups all elements of the stream by chunks of the given size, returning an array of arrays.\r\n\r\nAlias: `partitionBy`\r\n\r\n##### joining(options)\r\n\r\nJoins all elements of the stream into a string, using the following non-required options: `options.delimiter`, `options.prefix`, `options.suffix`.\r\n\r\nAlias: `join`\r\n \r\n## Stream.Optional\r\n\r\nWraps a single value which may be `null` or `undefined`.\r\n\r\n##### Optional.of(value)\r\n\r\nCreates a new optional wrapper for the given non-null and non-undefined value.\r\n\r\n##### Optional.ofNullable(value)\r\n\r\nCreates a new optional wrapper for the given value. The value may be null or undefined.\r\n\r\n##### Optional.empty()\r\n\r\nCreates a new empty optional wrapper (same as `Optional.ofNullable(null)`).\r\n\r\n##### get()\r\n\r\nReturns the value if a value is present, otherwise throws an error.\r\n\r\n##### isPresent()\r\n\r\nCheck if a value is present.\r\n\r\n##### ifPresent(consumer)\r\n\r\nInvoke the given consumer function for the specified value if present.\r\n\r\n##### orElse(other)\r\n\r\nReturns the value if present, otherwise return the given `other` value.\r\n\r\n##### orElseGet(supplier)\r\n\r\nReturns the value if present, otherwise return the result of invoking the supplier function.\r\n\r\n##### orElseThrow(error)\r\n\r\nReturns the value if present, otherwise throw the given error.\r\n\r\n##### filter(predicate)\r\n\r\nIf a value is present and value matches the given predicate function, returns this optional, otherwise return an empty optional.\r\n\r\n##### map(mappingFn)\r\n\r\nIf a value is present apply the given mapping function and wrap the resulting value with an optional.\r\n\r\n##### flatMap(mappingFn)\r\n\r\nIf a value is present apply the given optional-returning mapping function, and return the optional result or empty.\r\n\r\n# Copyright and license\r\n\r\nCreated and copyright (c) 2014-2015 by Benjamin Winterberg. Stream.js may be freely distributed under the MIT license.\r\n","google":"UA-48569937-1","note":"Don't delete this file! It's used internally to help with page regeneration."}